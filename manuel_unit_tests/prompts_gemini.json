{
  "32": {
    "diff": "easy",
    "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\nNewton-Raphson method should be included.\n   >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
    "tests": "import unittest\r\nimport math\r\n\r\nclass TestFindZero(unittest.TestCase):\r\n    def test_linear_zero(self):\r\n        self.assertAlmostEqual(find_zero([1, 2]), -0.5, places=2)\r\n\r\n    def test_cubic_zero(self):\r\n        self.assertAlmostEqual(find_zero([-6, 11, -6, 1]), 1.0, places=2)\r\n\r\n    def test_zero_at_origin(self):\r\n        self.assertAlmostEqual(find_zero([0, 0]), 0.0, places=2)\r\n\r\n    def test_negative_root(self):\r\n        self.assertAlmostEqual(find_zero([4, 2]), -2, places=2)\r\n\r\n    def test_large_coefficients(self):\r\n        self.assertAlmostEqual(find_zero([1000, -5000]), 0.2, places=2)\r\n"
  },
  "34": {
    "diff": "easy",
    "prompt": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
    "tests": "import unittest\r\n\r\nclass TestUnique(unittest.TestCase):\r\n    def test_mixed_duplicates(self):\r\n        self.assertEqual(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]), [0, 2, 3, 5, 9, 123])\r\n\r\n    def test_all_unique(self):\r\n        self.assertEqual(unique([7, 1, 4]), [1, 4, 7])\r\n\r\n    def test_all_duplicates(self):\r\n        self.assertEqual(unique([2, 2, 2, 2]), [2])\r\n\r\n    def test_empty_list(self):\r\n        self.assertEqual(unique([]), [])\r\n\r\n    def test_unsorted_input(self):\r\n        self.assertEqual(unique([10, 1, 5, 10, 2]), [1, 2, 5, 10])\r\n"
  },
  "38": {
    "diff": "easy",
    "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n   encode_cyclic function should be in the response without any change\n    \"\"\"\n",
    "tests": "import unittest\r\n\r\nclass TestCyclicEncoding(unittest.TestCase):\r\n    def test_full_groups(self):\r\n        self.assertEqual(decode_cyclic(encode_cyclic(\"abcdefghi\")), \"abcdefghi\")\r\n\r\n    def test_partial_group_end(self):\r\n        self.assertEqual(decode_cyclic(encode_cyclic(\"abcdefgh\")), \"abcdefgh\")\r\n\r\n    def test_two_character_string(self):\r\n        self.assertEqual(decode_cyclic(encode_cyclic(\"ab\")), \"ab\")\r\n\r\n    def test_single_character_string(self):\r\n        self.assertEqual(decode_cyclic(encode_cyclic(\"x\")), \"x\")\r\n\r\n    def test_empty_string(self):\r\n        self.assertEqual(decode_cyclic(encode_cyclic(\"\")), \"\")\r\n"
  },
  "45": {
    "diff": "easy",
    "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
    "tests": "import unittest\r\n\r\nclass TestTriangleArea(unittest.TestCase):\r\n    def test_integer_inputs(self):\r\n        self.assertEqual(triangle_area(5, 3), 7.5)\r\n\r\n    def test_float_inputs(self):\r\n        self.assertEqual(triangle_area(4.0, 2.5), 5.0)\r\n\r\n    def test_zero_height(self):\r\n        self.assertEqual(triangle_area(5, 0), 0.0)\r\n\r\n    def test_zero_base(self):\r\n        self.assertEqual(triangle_area(0, 10), 0.0)\r\n\r\n    def test_large_values(self):\r\n        self.assertEqual(triangle_area(10000, 20000), 100000000.0)\r\n"
  },
  "50": {
    "diff": "easy",
    "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestShiftEncoding(unittest.TestCase):\n    def test_basic_shift(self):\n        self.assertEqual(decode_shift(encode_shift(\"abcde\")), \"abcde\")\n\n    def test_wraparound_shift(self):\n        self.assertEqual(decode_shift(encode_shift(\"vwxyz\")), \"vwxyz\")\n\n    def test_repeated_characters(self):\n        self.assertEqual(decode_shift(encode_shift(\"aaaaa\")), \"aaaaa\")\n\n    def test_mixed_string(self):\n        self.assertEqual(decode_shift(encode_shift(\"azbycx\")), \"azbycx\")\n\n    def test_empty_string(self):\n        self.assertEqual(decode_shift(encode_shift(\"\")), \"\")"
  },
  "83": {
    "diff": "easy",
    "prompt": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n   Exclude numbers that start with zero like \"01\", \"021\".\n     \"\"\"\n",
    "tests": "import unittest\n\nclass TestStartsOneEnds(unittest.TestCase):\n    def test_single_digit(self):\n        self.assertEqual(starts_one_ends(1), 1)\n\n    def test_two_digits(self):\n        self.assertEqual(starts_one_ends(2), 18)\n\n    def test_three_digits(self):\n        self.assertEqual(starts_one_ends(3), 180)\n\n    def test_large_digit(self):\n        self.assertTrue(starts_one_ends(6) > 0)\n\n    def test_edge_case_two(self):\n        self.assertEqual(starts_one_ends(4), 1800)"
  },
  "162": {
    "diff": "easy",
    "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
    "tests": "import unittest\nimport hashlib\n\nclass TestStringToMd5(unittest.TestCase):\n    def test_hello_world(self):\n        self.assertEqual(string_to_md5(\"Hello world\"), hashlib.md5(\"Hello world\".encode()).hexdigest())\n\n    def test_empty_string(self):\n        self.assertIsNone(string_to_md5(\"\"))\n\n    def test_numeric_string(self):\n        self.assertEqual(string_to_md5(\"12345\"), hashlib.md5(\"12345\".encode()).hexdigest())\n\n    def test_special_characters(self):\n        self.assertEqual(string_to_md5(\"!@#$%^&*()\"), hashlib.md5(\"!@#$%^&*()\".encode()).hexdigest())\n\n    def test_long_string(self):\n        long_str = \"a\" * 1000\n        self.assertEqual(string_to_md5(long_str), hashlib.md5(long_str.encode()).hexdigest())"
  },
  "28": {
    "diff": "easy",
    "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestConcatenate(unittest.TestCase):\n    def test_empty_list(self):\n        self.assertEqual(concatenate([]), \"\")\n\n    def test_single_element(self):\n        self.assertEqual(concatenate([\"hello\"]), \"hello\")\n\n    def test_multiple_strings(self):\n        self.assertEqual(concatenate([\"a\", \"b\", \"c\"]), \"abc\")\n\n    def test_whitespace_strings(self):\n        self.assertEqual(concatenate([\" \", \" \", \" \"]), \"   \")\n\n    def test_mixed_strings(self):\n        self.assertEqual(concatenate([\"foo\", \"\", \"bar\", \"baz\"]), \"foobarbaz\")"
  },
  "29": {
    "diff": "easy",
    "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestFilterByPrefix(unittest.TestCase):\n    def test_empty_list(self):\n        self.assertEqual(filter_by_prefix([], \"a\"), [])\n\n    def test_no_matches(self):\n        self.assertEqual(filter_by_prefix([\"dog\", \"cat\", \"bird\"], \"z\"), [])\n\n    def test_some_matches(self):\n        self.assertEqual(filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"), [\"abc\", \"array\"])\n\n    def test_all_match(self):\n        self.assertEqual(filter_by_prefix([\"apple\", \"ape\", \"april\"], \"a\"), [\"apple\", \"ape\", \"april\"])\n\n    def test_case_sensitive(self):\n        self.assertEqual(filter_by_prefix([\"Apple\", \"apple\", \"APE\"], \"A\"), [\"Apple\", \"APE\"])"
  },
  "33": {
    "diff": "moderate",
    "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestSortThird(unittest.TestCase):\n    def test_no_index_div_3(self):\n        self.assertEqual(sort_third([1, 2]), [1, 2])\n\n    def test_exact_index_div_3(self):\n        self.assertEqual(sort_third([3, 1, 4, 2, 0, 5]), [2, 1, 4, 3, 0, 5])\n\n    def test_unsorted_div_3_indices(self):\n        self.assertEqual(sort_third([5, 6, 3, 4, 8, 9, 2]), [2, 6, 3, 4, 8, 9, 5])\n\n    def test_all_index_div_3(self):\n        self.assertEqual(sort_third([9, 1, 2, 8, 3, 4, 7, 5, 6]), [7, 1, 2, 8, 3, 4, 9, 5, 6])\n\n    def test_empty_list(self):\n        self.assertEqual(sort_third([]), [])"
  },
  "37": {
    "diff": "moderate",
    "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestSortEven(unittest.TestCase):\n    def test_basic_case(self):\n        self.assertEqual(sort_even([5, 6, 3, 4]), [3, 6, 5, 4])\n\n    def test_no_even_index(self):\n        self.assertEqual(sort_even([1]), [1])\n\n    def test_only_even_indices(self):\n        self.assertEqual(sort_even([4, 0, 2, 0]), [2, 0, 4, 0])\n\n    def test_all_even_sorted(self):\n        self.assertEqual(sort_even([2, 3, 4, 5, 6, 7]), [2, 3, 4, 5, 6, 7])\n\n    def test_empty_list(self):\n        self.assertEqual(sort_even([]), [])"
  },
  "42": {
    "diff": "moderate",
    "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestIncrList(unittest.TestCase):\n    def test_positive_numbers(self):\n        self.assertEqual(incr_list([1, 2, 3]), [2, 3, 4])\n\n    def test_mixed_numbers(self):\n        self.assertEqual(incr_list([-1, 0, 1]), [0, 1, 2])\n\n    def test_all_zeros(self):\n        self.assertEqual(incr_list([0, 0, 0]), [1, 1, 1])\n\n    def test_empty_list(self):\n        self.assertEqual(incr_list([]), [])\n\n    def test_large_numbers(self):\n        self.assertEqual(incr_list([999, 1000]), [1000, 1001])"
  },
  "53": {
    "diff": "moderate",
    "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestAdd(unittest.TestCase):\n    def test_positive_numbers(self):\n        self.assertEqual(add(2, 3), 5)\n\n    def test_negative_numbers(self):\n        self.assertEqual(add(-4, -6), -10)\n\n    def test_mixed_sign_numbers(self):\n        self.assertEqual(add(-3, 7), 4)\n\n    def test_zero_addition(self):\n        self.assertEqual(add(0, 5), 5)\n\n    def test_large_numbers(self):\n        self.assertEqual(add(1000000, 2000000), 3000000)"
  },
  "59": {
    "diff": "moderate",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestLargestPrimeFactor(unittest.TestCase):\n    def test_example_case(self):\n        self.assertEqual(largest_prime_factor(13195), 29)\n\n    def test_power_of_two(self):\n        self.assertEqual(largest_prime_factor(2048), 2)\n\n    def test_composite_with_large_prime(self):\n        self.assertEqual(largest_prime_factor(91), 13)\n\n    def test_small_composite(self):\n        self.assertEqual(largest_prime_factor(6), 3)\n\n    def test_multiple_small_factors(self):\n        self.assertEqual(largest_prime_factor(60), 5)"
  },
  "69": {
    "diff": "moderate",
    "prompt": "\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
    "tests": "import unittest\n\nclass TestSearch(unittest.TestCase):\n    def test_example_one(self):\n        self.assertEqual(search([4, 1, 2, 2, 3, 1]), 2)\n\n    def test_example_two(self):\n        self.assertEqual(search([1, 2, 2, 3, 3, 3, 4, 4, 4]), 3)\n\n    def test_example_three(self):\n        self.assertEqual(search([5, 5, 4, 4, 4]), -1)\n\n    def test_all_same_values(self):\n        self.assertEqual(search([2, 2, 2, 2]), 2)\n\n    def test_no_valid_value(self):\n        self.assertEqual(search([6, 6, 6, 6, 6]), -1)"
  },
  "90": {
    "diff": "moderate",
    "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestNextSmallest(unittest.TestCase):\n    def test_sorted_list(self):\n        self.assertEqual(next_smallest([1, 2, 3, 4, 5]), 2)\n\n    def test_unsorted_list(self):\n        self.assertEqual(next_smallest([5, 1, 4, 3, 2]), 2)\n\n    def test_empty_list(self):\n        self.assertIsNone(next_smallest([]))\n\n    def test_same_elements(self):\n        self.assertIsNone(next_smallest([1, 1]))\n\n    def test_with_negatives(self):\n        self.assertEqual(next_smallest([-5, -1, -3]), -3)"
  },
  "91": {
    "diff": "moderate",
    "prompt": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\" but not \"i\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestIsBored(unittest.TestCase):\n    def test_no_boredom(self):\n        self.assertEqual(is_bored(\"Hello world\"), 0)\n\n    def test_single_boredom(self):\n        self.assertEqual(is_bored(\"I am bored.\"), 1)\n\n    def test_multiple_boredoms(self):\n        self.assertEqual(is_bored(\"I am here. I am bored! I want fun?\"), 3)\n\n    def test_irregular_spacing(self):\n        self.assertEqual(is_bored(\"   I am alone .You are here. I know!\"), 2)\n\n    def test_lowercase_i(self):\n        self.assertEqual(is_bored(\"i am small. I am big.\"), 1)"
  },
  "94": {
    "diff": "moderate",
    "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestSkjkasdkd(unittest.TestCase):\n    def test_example_case_one(self):\n        self.assertEqual(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]), 10)\n\n    def test_example_case_two(self):\n        self.assertEqual(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]), 25)\n\n    def test_example_case_three(self):\n        self.assertEqual(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]), 13)\n\n    def test_example_case_four(self):\n        self.assertEqual(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]), 11)\n\n    def test_example_case_five(self):\n        self.assertEqual(skjkasdkd([0,8,1,2,1,7]), 7)"
  },
  "97": {
    "diff": "moderate",
    "prompt": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    Do the operations on different lines",
    "tests": "import unittest\n\nclass TestMultiply(unittest.TestCase):\n    def test_positive_digits(self):\n        self.assertEqual(multiply(148, 412), 16)\n\n    def test_single_digits(self):\n        self.assertEqual(multiply(9, 8), 72)\n\n    def test_zero_unit_digit(self):\n        self.assertEqual(multiply(2020, 1851), 0)\n\n    def test_negative_number(self):\n        self.assertEqual(multiply(14, -15), 20)\n\n    def test_both_negative(self):\n        self.assertEqual(multiply(-24, -13), 12)"
},
  "40": {
    "diff": "hard",
    "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestTriplesSumToZero(unittest.TestCase):\n    def test_no_zero_sum_triplet(self):\n        self.assertFalse(triples_sum_to_zero([1, 3, 5, 0]))\n\n    def test_valid_triplet_exists(self):\n        self.assertTrue(triples_sum_to_zero([1, 3, -2, 1]))\n\n    def test_all_positive(self):\n        self.assertFalse(triples_sum_to_zero([1, 2, 3, 7]))\n\n    def test_valid_negative_triplet(self):\n        self.assertTrue(triples_sum_to_zero([2, 4, -5, 3, 9, 7]))\n\n    def test_too_few_elements(self):\n        self.assertFalse(triples_sum_to_zero([1]))"
  },
  "44": {
    "diff": "hard",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestChangeBase(unittest.TestCase):\n    def test_base_three(self):\n        self.assertEqual(change_base(8, 3), '22')\n\n    def test_base_two(self):\n        self.assertEqual(change_base(8, 2), '1000')\n\n    def test_base_two_seven(self):\n        self.assertEqual(change_base(7, 2), '111')\n\n    def test_zero_value(self):\n        self.assertEqual(change_base(0, 2), '0')\n\n    def test_large_number(self):\n        self.assertEqual(change_base(255, 2), '11111111')"
  },
  "48": {
    "diff": "hard",
    "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n   Consider case sensitivity\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestIsPalindrome(unittest.TestCase):\n    def test_empty_string(self):\n        self.assertTrue(is_palindrome(''))\n\n    def test_simple_palindrome(self):\n        self.assertTrue(is_palindrome('aba'))\n\n    def test_repeating_characters(self):\n        self.assertTrue(is_palindrome('aaaaa'))\n\n    def test_non_palindrome(self):\n        self.assertFalse(is_palindrome('zbcd'))\n\n    def test_case_sensitivity(self):\n        self.assertFalse(is_palindrome('Aba'))"
  },
  "66": {
    "diff": "hard",
    "prompt": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestDigitSum(unittest.TestCase):\n    def test_empty_string(self):\n        self.assertEqual(digitSum(\"\"), 0)\n\n    def test_mixed_case(self):\n        self.assertEqual(digitSum(\"abAB\"), 131)\n\n    def test_single_uppercase(self):\n        self.assertEqual(digitSum(\"abcCd\"), 67)\n\n    def test_ending_uppercase(self):\n        self.assertEqual(digitSum(\"helloE\"), 69)\n\n    def test_multiple_uppercase(self):\n        self.assertEqual(digitSum(\"woArBld\"), 131)"
  },
  "67": {
    "diff": "hard",
    "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestFruitDistribution(unittest.TestCase):\n    def test_example_one(self):\n        self.assertEqual(fruit_distribution(\"5 apples and 6 oranges\", 19), 8)\n\n    def test_example_two(self):\n        self.assertEqual(fruit_distribution(\"0 apples and 1 oranges\", 3), 2)\n\n    def test_example_three(self):\n        self.assertEqual(fruit_distribution(\"2 apples and 3 oranges\", 100), 95)\n\n    def test_example_four(self):\n        self.assertEqual(fruit_distribution(\"100 apples and 1 oranges\", 120), 19)\n\n    def test_zero_total(self):\n        self.assertEqual(fruit_distribution(\"0 apples and 0 oranges\", 0), 0)"
  },
  "86": {
    "diff": "hard",
    "prompt": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestAntiShuffle(unittest.TestCase):\n    def test_single_word(self):\n        self.assertEqual(anti_shuffle('hello'), 'ehllo')\n\n    def test_single_uppercase_word(self):\n        self.assertEqual(anti_shuffle('Hi'), 'Hi')\n\n    def test_with_special_characters(self):\n        self.assertEqual(anti_shuffle('Hello World!!!'), 'Hello !!!Wdlor')\n\n    def test_multiple_words(self):\n        self.assertEqual(anti_shuffle('open ai test'), 'enop ai estt')\n\n    def test_empty_string(self):\n        self.assertEqual(anti_shuffle(''), '')"
  },
  "95": {
    "diff": "hard",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    Utilize advanced logic for detecting case by setting \"lower\" or \"upper\" or \"title\" for corresponding cases  \"\"\"\n",
    "tests": "import unittest\n\nclass TestCheckDictCase(unittest.TestCase):\n    def test_all_lowercase_keys(self):\n        self.assertTrue(check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}))\n\n    def test_mixed_case_keys(self):\n        self.assertFalse(check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}))\n\n    def test_non_string_key(self):\n        self.assertFalse(check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}))\n\n    def test_title_case_keys(self):\n        self.assertFalse(check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n\n    def test_all_uppercase_keys(self):\n        self.assertTrue(check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\"}))"
  },
  "107": {
    "diff": "hard",
    "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestEvenOddPalindrome(unittest.TestCase):\n    def test_example_one(self):\n        self.assertEqual(even_odd_palindrome(3), (1, 2))\n\n    def test_example_two(self):\n        self.assertEqual(even_odd_palindrome(12), (4, 6))\n\n    def test_single_digit(self):\n        self.assertEqual(even_odd_palindrome(1), (0, 1))\n\n    def test_full_range_check(self):\n        self.assertEqual(even_odd_palindrome(20), (4, 6))\n\n    def test_upper_bound(self):\n        result = even_odd_palindrome(1000)\n        self.assertIsInstance(result, tuple)\n        self.assertEqual(len(result), 2)"
  },
  "109": {
    "diff": "hard",
    "prompt": "\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestMoveOneBall(unittest.TestCase):\n    def test_sorted_array(self):\n        self.assertTrue(move_one_ball([1, 2, 3, 4, 5]))\n\n    def test_valid_shift(self):\n        self.assertTrue(move_one_ball([3, 4, 5, 1, 2]))\n\n    def test_invalid_shift(self):\n        self.assertFalse(move_one_ball([3, 5, 4, 1, 2]))\n\n    def test_single_element(self):\n        self.assertTrue(move_one_ball([10]))\n\n    def test_empty_array(self):\n        self.assertTrue(move_one_ball([]))"
  },
  "112": {
    "diff": "hard",
    "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestReverseDelete(unittest.TestCase):\n    def test_example_one(self):\n        self.assertEqual(reverse_delete(\"abcde\", \"ae\"), ('bcd', False))\n\n    def test_example_two(self):\n        self.assertEqual(reverse_delete(\"abcdef\", \"b\"), ('acdef', False))\n\n    def test_example_three(self):\n        self.assertEqual(reverse_delete(\"abcdedcba\", \"ab\"), ('cdedc', True))\n\n    def test_full_palindrome_remains(self):\n        self.assertEqual(reverse_delete(\"racecar\", \"z\"), ('racecar', True))\n\n    def test_remove_all(self):\n        self.assertEqual(reverse_delete(\"aaaa\", \"a\"), ('', True))"
  },
  "128": {
    "diff": "hard",
    "prompt": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
    "tests": "import unittest\n\nclass TestProdSigns(unittest.TestCase):\n    def test_mixed_numbers(self):\n        self.assertEqual(prod_signs([1, 2, 2, -4]), -9)\n\n    def test_with_zero(self):\n        self.assertEqual(prod_signs([0, 1]), 0)\n\n    def test_empty_list(self):\n        self.assertIsNone(prod_signs([]))\n\n    def test_all_positive(self):\n        self.assertEqual(prod_signs([1, 2, 3]), 6)\n\n    def test_all_negative(self):\n        self.assertEqual(prod_signs([-1, -2, -3]), -6)"
  }
}